import subprocess

from typing import Optional, Union

from pathlib import Path
from collections import defaultdict



def download_and_prepare_rfam_cms(destination: Union[str, Path]):
    """
    Download and prepare the Rfam cms.
    """
    destination = Path(destination)
    destination.mkdir(parents=True, exist_ok=True)

    subprocess.call(["wget", "https://ftp.ebi.ac.uk/pub/databases/Rfam/CURRENT/Rfam.clanin"], cwd=destination)
    subprocess.call(["wget", "https://ftp.ebi.ac.uk/pub/databases/Rfam/CURRENT/Rfam.cm.gz"], cwd=destination)
    subprocess.call(["gunzip", "Rfam.cm.gz"], cwd=destination)
    subprocess.call(["cmpress", "Rfam.cm"], cwd=destination)


def annotate_family(query_fasta: Union[str, Path],
                    rfam_dir: Union[str, Path],
                    working_dir : Optional[Union[str, Path]] = None) -> dict:
    """
    Annotate the family of the RNA sequence.
    """
    if not Path(rfam_dir, 'Rfam.cm').exists():
        download_and_prepare_rfam_cms(rfam_dir)

    if working_dir is None:
        working_dir = ''
    else:
        working_dir = Path(working_dir)
        working_dir.mkdir(parents=True, exist_ok=True)
    
    out_path = Path(working_dir, 'output.txt')
    
    get_family_information(query_fasta, Path(rfam_dir, 'Rfam.cm'), Path(rfam_dir, 'Rfam.clanin'), out_path)

    results = extract_info_from_tbl(out_path)

    return results

 
def get_family_information(
                           queries_fasta_path : str,
                           cm_path : str,
                           clanin_path : str,
                           outpath : str,
                           ):
    """
    Run cmscan to get the family information.
    """
    subprocess.call(["cmscan", "--rfam", "--cut_ga", "--nohmmonly", "--oskip", "--tblout", outpath, "--fmt", "2", "--clanin", clanin_path, cm_path, queries_fasta_path], stdout=subprocess.DEVNULL)  # remove , stdout=subprocess.DEVNULL to see output of command


def extract_info_from_tbl(tbl_path: Union[str, Path]) -> dict:
    """
    Extracts information from the tbl file generated by cmscan.
    """
    intermediate_results = defaultdict(list)

    with open(tbl_path, 'r') as f:
        lines = f.readlines()
        for line in lines:
            if line.startswith('#'):
                continue
            else:
                line = line.strip().split()
                # sample_id = line[0]
                target_name = line[1]
                accession = line[2]
                query_name = line[3]
                # query_accession = line[4]
                clan_name = line[5]
                # mdl = line[6]
                # mdl_from = line[7]
                # mdl_to = line[8]
                # seq_from = line[9]
                # seq_to = line[10]
                # strand = line[11]
                # trunc = line[12]
                # pass_val = line[13]
                # gc = line[14]
                # bias = line[15]
                score = line[16]
                e_value = line[17]
                # inc = line[18]
                # olp = line[19]
                # anyidx = line[20]
                # afrct1 = line[21]
                # afrct2 = line[22]
                # winidx = line[23]
                # wfrct1 = line[24]
                # wfrct2 = line[25]
                # description = line[26]

                intermediate_results[query_name].append({'family': target_name,
                                                         'rfam_id': accession,
                                                         'clan': clan_name,
                                                         'bit_score': float(score),
                                                         'e-value': float(e_value)})

        if not intermediate_results:
            return None
        
        results = {}

        for k, v in intermediate_results.items():
            # sort by e-value
            v = sorted(v, key=lambda x: x['e-value'], reverse=True)
            
            # aggregate all results into lists
            families = [d['family'] for d in intermediate_results[k]]
            accessions = [d['rfam_id'] for d in intermediate_results[k]]
            clans = [d['clan'] for d in intermediate_results[k]]
            bit_scores = [d['bit_score'] for d in intermediate_results[k]]
            e_values = [d['e-value'] for d in intermediate_results[k]]
            
            results[k] = {'families': families, 'accessions': accessions, 'clans': clans, 'bit-scores': bit_scores, 'e-values': e_values}
        
        return results
    
def annotate_families_from_sequence(sequence: str,
                                    rfam_dir: Union[str, Path],
                                    working_dir: Optional[Union[str, Path]] = None,
                                    seq_id: Optional[str] = None) -> dict:
    """
    Annotate the family of the RNA sequence.
    """
    if working_dir is None:
        working_dir = ''
    else:
        working_dir = Path(working_dir)
        working_dir.mkdir(parents=True, exist_ok=True)

    if seq_id is None:
        seq_id = 'sequence'
    fasta_path = Path(working_dir, f'{seq_id}.fasta')

    
    with open(fasta_path, 'w') as f:
        f.write(f'>{seq_id}\n{sequence}\n')
    
    results = annotate_family(fasta_path, rfam_dir)

    if results is not None:
        res = results[seq_id]
        return res
    

    return results

def annotate_families_from_sequences(sequences: list,
                                     rfam_dir: Union[str, Path],
                                     working_dir: Optional[Union[str, Path]] = None,
                                     seq_ids: Optional[list] = None) -> dict:
    """
    Annotate the family of the RNA sequences.
    """
    if working_dir is None:
        working_dir = ''
    else:
        working_dir = Path(working_dir)
        working_dir.mkdir(parents=True, exist_ok=True)

    results = {}

    if seq_ids is None:
        seq_ids = [f'sequence_{i}' for i in range(len(sequences))]

    fasta_path = Path(working_dir, 'sequences.fasta')
    
    with open(fasta_path, 'w+') as f:
        for i, sequence in zip(seq_ids, sequences):
            f.write(f'>{i}\n{sequence}\n')
    results = annotate_family(fasta_path, rfam_dir, working_dir)

    for seq_id in seq_ids:
        if not seq_id in results.keys():
            results[seq_id] = None
    
    return results


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description='Annotate RNA families using Rfam.')

    parser.add_argument('--sequence', type=str, default='GAGAGCGTAGCTCAGTCGGTAGAGCAACTGACTTTTAATCAGTAGGTCATGGGTTCGAATCCCATCGCTCTCA', help='RNA sequence to annotate.')
    parser.add_argument('--sequences', type=str, default=['GGA' * 100,'GAGAGCGTAGCTCAGTCGGTAGAGCAACTGACTTTTAATCAGTAGGTCATGGGTTCGAATCCCATCGCTCTCA', 'AGCGGGTAGCGGGAATCGAACCCGCGTCACTGGCTTGGAAGGCCAGCGCTCTACCATTGAGCTATACCCGC'], nargs='+', help='RNA sequences to annotate.')
    parser.add_argument('--rfam_dir', type=Path, default=Path('data/rfam'), help='Directory containing the Rfam files.')
    parser.add_argument('--working_dir', type=Path, default=Path('working_dir'), help='Working directory to store intermediate files.')
    parser.add_argument('--seq_id', type=str, help='Sequence ID.')
    parser.add_argument('--seq_ids', type=str, nargs='+', help='Sequence IDs.')
    parser.add_argument('--fasta_file', type=str, help='existing sequence fasta file.')

    args = parser.parse_args()

    results = annotate_families_from_sequence(args.sequence, args.rfam_dir, args.working_dir, args.seq_id)

    print(results)

    # results = annotate_families_from_sequences(args.sequences, args.rfam_dir, args.working_dir)
# 
    # print(results)

    
    # rfam_dir = Path('data/rfam')
    # working_dir = Path('data/working')

    # # test single sequences
    # sequence = 'GGA' * 100
    # results = annotate_families_from_sequence(sequence, rfam_dir, working_dir)
    # print(results)
# 
    # sequence = 'GAGAGCGTAGCTCAGTCGGTAGAGCAACTGACTTTTAATCAGTAGGTCATGGGTTCGAATCCCATCGCTCTCA'
    # seq_id = 'AQHN01000061.1:205737-205809'
    # results = annotate_families_from_sequence(sequence, rfam_dir, working_dir, seq_id)
    # print(results)
# 
    # 
    # # test multiple sequences
    # print()
    # sequences = [
    #     'GGA' * 100,
    #     'GAGAGCGTAGCTCAGTCGGTAGAGCAACTGACTTTTAATCAGTAGGTCATGGGTTCGAATCCCATCGCTCTCA',
    #     'AGCGGGTAGCGGGAATCGAACCCGCGTCACTGGCTTGGAAGGCCAGCGCTCTACCATTGAGCTATACCCGC',
    # ]
    # results = annotate_families_from_sequences(sequences, rfam_dir, working_dir)
    # print(results)
# 
    # # test with existing fasta file
    # print()
    # fasta_path = Path('data/working/sequences.fasta')
    # results = annotate_family(fasta_path, rfam_dir)
# 
    # for k, v in results.items():
    #     print(k)
    #     print(v)
    # 
    # # clean up
    # for f in Path(working_dir).glob('*'):
    #     f.unlink()
    # working_dir.rmdir()